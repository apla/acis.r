package ACIS::Citations::Search;

use strict;
use warnings;

use Carp;
use Encode;

use ACIS::Citations::Utils;
use ACIS::Citations::Suggestions;

# exportable:
# 
#   search_for_document( docid )
#             - find pre-identified citations [30 min]
#
#   search_for_personal_names( names ) - [30 min]
#             - names must be a set of normalized strings
#
#   compare_citation_to_doc( $cit, $doc ) 
#             - find out similarity value and store it [60 min]
#
#   filter_search_results( $results, $filterset )
#             - used to filter out identified or refused citations [45 min]
#
#   sort_search_results( $results, $matrix ) [45 min]
#
#

use Web::App::Common;

my $acis;
my $sql;

sub prepare() {
  $acis = $ACIS::Web::ACIS;
  $sql  = $acis -> sql_object;
}


sub search_for_document($) {
  my $docid = shift || die;
  if ( not $sql ) { prepare; }

  debug "search_for_documents: $docid";

  $sql -> prepare_cached( "select * from citations where trgdocid=?" );
  my $r = $sql -> execute( $docid );
  my @cl = ();
  while ( $r and $r->{row} ) {
    my $c = { %{$r->{row}} };
    $c->{ostring} = Encode::decode_utf8( $c->{ostring} );
    $c->{nstring} = Encode::decode_utf8( $c->{nstring} );
    push @cl, $c;
    $r->next;
  }
  debug "search_for_documents: found ", scalar @cl, " items";
  return \@cl;
}


use ACIS::Citations::SimMatrix;

sub search_for_personal_names($) {
  my $names = shift || die;

  if ( not $sql ) { prepare; }

  debug "search_for_personal_names: $names (" , scalar @$names, " items)";

  my @cl = ();
  $sql -> prepare_cached( "select * from citations where nstring REGEXP ?" );
  foreach ( @$names ) {
    my $n = $_;
    $n =~ s/[\.{}()|*?]/\\$1/g;
    my $r = $sql -> execute( "[[:<:]]$n\[[:>:]]" );
    while ( $r and $r->{row} ) {
      my $c = { %{$r->{row}} };
      $c->{ostring} = Encode::decode_utf8( $c->{ostring} );
      $c->{nstring} = Encode::decode_utf8( $c->{nstring} );
      push @cl, $c;
      $r->next;
    }
  }

  debug "search_for_personal_names: found ", scalar @cl, " citations";
  return \@cl;
  
}


sub test_search() {
  require ACIS::Web;
  # home=> '/home/ivan/proj/acis.zet'
  my $acis = ACIS::Web->new(  );
  search_for_document( 'repec:fdd:fodooo:555' );
  search_for_personal_names( [ 'JOHN MAKLORVICH', 'KATZ HARRY', 'KATZ, HARRY'  ] );
}



sub filter_search_results($$) {
  my ( $results, $filterset ) = @_;

  # $filterset is a hash of the form { "srcdocsid-checksum" => citation }
  # as generated by build_citations_index in ACIS::Citations::Utils.

  foreach ( @$results ) {
    my $key = $_->{srcdocsid} . '-' . $_->{checksum};
    if ( $filterset->{$key} ) {
      undef $_;
    }
  }

  return clear_undefined $results;
  # clear_undefined returns the number of items cleared
}



sub personal_search_by_documents {
  my $rec  = shift;
  my $psid = $rec->{sid};
  my $rp   = $rec->{contributions}{accepted} || [];

  # make an index of research profile items by sid
  my $rp_sid = {};
  foreach ( @$rp ) {
    my $sid = $_->{sid};
    if ( $sid ) {
      $rp_sid->{$sid} = $_;
    }
  }

  # build identified index and refused index
  my $identified = {};
  my $refused    ;

  {  
    my $identified_hl = $rec->{citations}{identified} || {};
    my $refused_l     = $rec->{citations}{refused}    || [];
    
    foreach ( keys %$identified_hl ) {
      my $list = $identified_hl ->{$_};
      build_citations_index $list, $identified;
    }

    $refused = build_citations_index $refused_l;
  }

  # search 
  foreach ( @$rp ) {
    my $did  = $_->{id};
    my $dsid = $_->{sid};
    
    my $r = search_for_document( $did );

    # process results
    filter_search_results( $r, $identified );
    filter_search_results( $r, $refused );
    foreach ( @$r ) {
      replace_suggestion( $_, $psid, $dsid, "preidentified", undef );
    }
  }
  
}




sub personal_search_by_names {
  my $rec  = shift;
  my $psid = $rec->{sid};
  my $rp   = $rec->{contributions}{accepted} || [];

  # make an index of research profile items by sid
  my $rp_sid = {};
  foreach ( @$rp ) {
    my $sid = $_->{sid};
    if ( $sid ) {
      $rp_sid->{$sid} = $_;
    }
  }

  # build identified index and refused index
  my $identified = {};
  my $refused    ;

  {  
    my $identified_hl = $rec->{citations}{identified} || {};
    my $refused_l     = $rec->{citations}{refused}    || [];
    
    foreach ( keys %$identified_hl ) {
      my $list = $identified_hl ->{$_};
      build_citations_index $list, $identified;
    }

    $refused = build_citations_index $refused_l;
  }

  # list of names 
  my $names = $rec->{names}{additional-variations};
  # XXX prepare the names, normalize them or at least remove final dots

  # search 
  my $r = search_for_personal_names( $names );

  # filter
  filter_search_results( $r, $identified );
  filter_search_results( $r, $refused );


  # load the matrix
  my $mat = load_similarity_matrix( $psid );

  # compare to documents!

  foreach ( @$r ) {
    my $citation = $_;
    foreach ( @$rp ) {
      my $doc  = $_;
      my $dsid = $_->{sid};
      my $potentialnew = $mat->{new}{$dsid} || [];
      my $potentialold = $mat->{old}{$dsid} || [];

      my $found;
      foreach ( @$potentialnew, @$potentialold ) {
        if ( $_->{srcdocsid} eq $citation->{srcdocsid} 
             and $_->{checksum} eq $citation->{checksum} ) {
          if ( $_->{reason} eq 'similar' ) {
            $found = $_;
            last;
          }
        }
      }

      if ( not $found ) {
        # compare $citation and $doc and save
        # XXX
        replace_suggestion( $_, $psid, $dsid, "similar", XXX );
      }
  }
  
}






1;



